###### Проведенные тесты -XX:+UseParallelGC, -XX:+UseG1GC
Устройство Intel Core I7-7700HQ CPU @ 2.8 GHz 2.8 GHz

**Вывод:**

В моем конкретном случае, лучшим из вышеописанных gc оказался G1.
По результатам тестирования, G1 показал более частую сборку young generation с меньшим значением времени сборки в целом 
и так же с меньшим временем отдельно каждого старта сборки.

Так же при увеличении доступной памяти (у меня с 1гб), время жизни приложения со сборкой c G1 до падения с OutOfMemory было выше чем 
у сборки с ParallelGC.

Был использованы так же параметр  -XX:MaxGCPauseMillis= , для некого тюнинга. Этот параметр в основном оказывал влияние
на G1, заставляя его запускать сборку реже или чаще (большее значение и меньшее соотвественно).
В случае ParallelGC особых изменений замечено не было.

Интересная особенность. В графика visualVM при использовании G1 использование процессора гораздо более активно и стабильно
(в моем случае около 60% - 70%), когда при ParallelGC использование CPU происходит всплесками вместе с активностью самого GC.

Можно сделать вывод, что ParallelGC имеет преимущества в приложениях где необходима бОльшая производительность 
за счет меньшего потребления ресурсов CPU.

Ссылка с некоторыми результатами тестирования.
https://docs.google.com/spreadsheets/d/1sKkgHrWb6QbEFx0QxU7AUkBj0oxCxhDocdNK_beK3VM/edit?usp=sharing

P.S Несколько раз при использовании ParallelGC на небольших объемах памяти, когда в VisualVM видно достижения пика(по памяти в heap), 
приложение зависало, но при этом нагрузка на процессор продолжала существовать, а в heap не происходило изменения по памяти,
она и не очищалась, и не загружалась дальнейшим выполнением скрипта.
