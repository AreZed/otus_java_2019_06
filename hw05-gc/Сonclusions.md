###### Проведенные тесты -XX:+UseParallelGC, -XX:+UseG1GC
Устройство Intel Core I7-7700HQ CPU @ 2.8 GHz 2.8 GHz

**Вывод:**

~~В моем конкретном случае, лучшим из вышеописанных gc оказался G1.
По результатам тестирования, G1 показал более частую сборку young generation с меньшим значением времени сборки в целом 
и так же с меньшим временем отдельно каждого старта сборки.~~

**UPD:** Оба GC имеют свои преимущества. Какой именно использовать решать можно только исходя из требований к приложению.

При увеличении доступной памяти (у меня с 1гб), время жизни приложения со сборкой c G1 до падения с OutOfMemory было выше чем 
у сборки с ParallelGC.

~~Интересная особенность.~~ В графика visualVM при использовании G1 использование процессора гораздо более активно и стабильно
(в моем случае около 60% - 70%), когда при ParallelGC использование CPU происходит всплесками вместе с активностью самого GC.
**UPD:** Данные момент отражает stop-the-world эффект при запуске сборки. thanks @petrelevich

~~Можно сделать вывод, что ParallelGC имеет преимущества в приложениях где необходима бОльшая производительность 
за счет меньшего потребления ресурсов CPU.~~

**UPD:** Было проверено данное утверждение, в результате чего можно утверждать, что throughput(пропускная способность)
 у ParallelGC выше, чем у G1.

Ссылка с некоторыми результатами тестирования.
https://docs.google.com/spreadsheets/d/1sKkgHrWb6QbEFx0QxU7AUkBj0oxCxhDocdNK_beK3VM/edit?usp=sharing

P.S Несколько раз при использовании ParallelGC на небольших объемах памяти, когда в VisualVM видно достижения пика(по памяти в heap), 
приложение зависало, но при этом нагрузка на процессор продолжала существовать, а в heap не происходило изменения по памяти,
она и не очищалась, и не загружалась дальнейшим выполнением скрипта.

 